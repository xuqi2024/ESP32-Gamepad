# ESP32-Gamepad é¡¹ç›®åŸºç¡€æ¶æ„æ­å»º

## ğŸ“ ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºESP-IDFé¡¹ç›®åŸºç¡€æ–‡ä»¶

### 1.1 åˆ›å»ºä¸»CMakeLists.txt

è¿™æ˜¯ESP-IDFé¡¹ç›®çš„å…¥å£é…ç½®æ–‡ä»¶ï¼Œå®šä¹‰äº†é¡¹ç›®çš„åŸºæœ¬ä¿¡æ¯å’Œæ„å»ºè§„åˆ™ã€‚

```cmake
# ESP-IDFé¡¹ç›®æœ€ä½ç‰ˆæœ¬è¦æ±‚
cmake_minimum_required(VERSION 3.16)

# é¡¹ç›®åŸºæœ¬ä¿¡æ¯
set(PROJECT_NAME "esp32_gamepad")
set(PROJECT_VER "1.0.0")

# åŒ…å«ESP-IDFæ„å»ºç³»ç»Ÿ
include($ENV{IDF_PATH}/tools/cmake/project.cmake)

# å®šä¹‰é¡¹ç›®
project(${PROJECT_NAME})

# é¡¹ç›®æè¿°
set(PROJECT_DESCRIPTION "ESP32 Bluetooth Gamepad Controller for RC Cars and Planes")
```

### 1.2 åˆ›å»ºmainç»„ä»¶

mainç»„ä»¶æ˜¯ESP-IDFé¡¹ç›®çš„æ ¸å¿ƒï¼ŒåŒ…å«ç¨‹åºå…¥å£ç‚¹ã€‚

#### main/CMakeLists.txt
```cmake
# æ³¨å†Œmainç»„ä»¶
idf_component_register(
    SRCS "main.c" 
         "gamepad_controller.c"
    INCLUDE_DIRS "."
    REQUIRES 
        bt
        esp_bt_bluedroid
        nvs_flash
        driver
        bluetooth_hid
        device_control
        vibration
        config
)
```

#### main/main.c - ç¨‹åºå…¥å£ç‚¹
```c
/**
 * @file main.c
 * @brief ESP32 Gamepad Controller ä¸»ç¨‹åº
 * @version 1.0.0
 * @date 2025-07-07
 */

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "esp_bt.h"
#include "esp_bt_main.h"
#include "esp_bt_device.h"
#include "gamepad_controller.h"

static const char *TAG = "MAIN";

/**
 * @brief ç³»ç»Ÿåˆå§‹åŒ–
 */
static void system_init(void)
{
    // åˆå§‹åŒ–NVSå­˜å‚¨
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    ESP_LOGI(TAG, "NVS Flash initialized");
}

/**
 * @brief è“ç‰™åˆå§‹åŒ–
 */
static void bluetooth_init(void)
{
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));
    
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_bt_controller_init(&bt_cfg));
    ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT));
    ESP_ERROR_CHECK(esp_bluedroid_init());
    ESP_ERROR_CHECK(esp_bluedroid_enable());
    
    ESP_LOGI(TAG, "Bluetooth initialized");
}

/**
 * @brief åº”ç”¨ç¨‹åºä¸»å‡½æ•°
 */
void app_main(void)
{
    ESP_LOGI(TAG, "ESP32 Gamepad Controller Starting...");
    ESP_LOGI(TAG, "Version: %s", "1.0.0");
    ESP_LOGI(TAG, "Build Date: %s %s", __DATE__, __TIME__);
    
    // ç³»ç»Ÿåˆå§‹åŒ–
    system_init();
    
    // è“ç‰™åˆå§‹åŒ–
    bluetooth_init();
    
    // æ¸¸æˆæ‰‹æŸ„æ§åˆ¶å™¨åˆå§‹åŒ–
    gamepad_controller_init();
    
    ESP_LOGI(TAG, "System initialization completed");
    
    // ä¸»å¾ªç¯
    while (1) {
        // ç³»ç»Ÿå¿ƒè·³
        ESP_LOGI(TAG, "System running...");
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}
```

### 1.3 åˆ›å»ºæ¸¸æˆæ‰‹æŸ„æ§åˆ¶å™¨æ¡†æ¶

#### main/gamepad_controller.h
```c
/**
 * @file gamepad_controller.h
 * @brief æ¸¸æˆæ‰‹æŸ„æ§åˆ¶å™¨å¤´æ–‡ä»¶
 */

#ifndef GAMEPAD_CONTROLLER_H
#define GAMEPAD_CONTROLLER_H

#include "esp_err.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief æ§åˆ¶æ¨¡å¼æšä¸¾
 */
typedef enum {
    CONTROL_MODE_CAR = 0,    ///< å°è½¦æ§åˆ¶æ¨¡å¼
    CONTROL_MODE_PLANE,      ///< é£æœºæ§åˆ¶æ¨¡å¼
    CONTROL_MODE_DISABLED    ///< ç¦ç”¨æ¨¡å¼
} control_mode_t;

/**
 * @brief æ‰‹æŸ„æŒ‰é”®çŠ¶æ€ç»“æ„ä½“
 */
typedef struct {
    bool button_a;           ///< Aé”®çŠ¶æ€
    bool button_b;           ///< Bé”®çŠ¶æ€
    bool button_x;           ///< Xé”®çŠ¶æ€
    bool button_y;           ///< Yé”®çŠ¶æ€
    bool button_l1;          ///< L1é”®çŠ¶æ€
    bool button_r1;          ///< R1é”®çŠ¶æ€
    bool button_select;      ///< é€‰æ‹©é”®çŠ¶æ€
    bool button_start;       ///< å¼€å§‹é”®çŠ¶æ€
} gamepad_buttons_t;

/**
 * @brief æ‰‹æŸ„æ‘‡æ†çŠ¶æ€ç»“æ„ä½“
 */
typedef struct {
    int16_t left_x;          ///< å·¦æ‘‡æ†Xè½´ (-32768 to 32767)
    int16_t left_y;          ///< å·¦æ‘‡æ†Yè½´ (-32768 to 32767)
    int16_t right_x;         ///< å³æ‘‡æ†Xè½´ (-32768 to 32767)
    int16_t right_y;         ///< å³æ‘‡æ†Yè½´ (-32768 to 32767)
    uint8_t left_trigger;    ///< å·¦æ‰³æœº (0 to 255)
    uint8_t right_trigger;   ///< å³æ‰³æœº (0 to 255)
} gamepad_sticks_t;

/**
 * @brief å®Œæ•´çš„æ‰‹æŸ„çŠ¶æ€ç»“æ„ä½“
 */
typedef struct {
    gamepad_buttons_t buttons;
    gamepad_sticks_t sticks;
    bool connected;          ///< è¿æ¥çŠ¶æ€
} gamepad_state_t;

/**
 * @brief åˆå§‹åŒ–æ¸¸æˆæ‰‹æŸ„æ§åˆ¶å™¨
 * @return ESP_OK æˆåŠŸï¼Œå…¶ä»–å€¼è¡¨ç¤ºé”™è¯¯
 */
esp_err_t gamepad_controller_init(void);

/**
 * @brief è®¾ç½®æ§åˆ¶æ¨¡å¼
 * @param mode æ§åˆ¶æ¨¡å¼
 * @return ESP_OK æˆåŠŸï¼Œå…¶ä»–å€¼è¡¨ç¤ºé”™è¯¯
 */
esp_err_t gamepad_controller_set_mode(control_mode_t mode);

/**
 * @brief è·å–å½“å‰æ‰‹æŸ„çŠ¶æ€
 * @param state è¾“å‡ºçš„æ‰‹æŸ„çŠ¶æ€
 * @return ESP_OK æˆåŠŸï¼Œå…¶ä»–å€¼è¡¨ç¤ºé”™è¯¯
 */
esp_err_t gamepad_controller_get_state(gamepad_state_t *state);

/**
 * @brief å‘é€éœ‡åŠ¨åé¦ˆ
 * @param intensity éœ‡åŠ¨å¼ºåº¦ (0-255)
 * @param duration_ms éœ‡åŠ¨æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
 * @return ESP_OK æˆåŠŸï¼Œå…¶ä»–å€¼è¡¨ç¤ºé”™è¯¯
 */
esp_err_t gamepad_controller_vibrate(uint8_t intensity, uint32_t duration_ms);

#ifdef __cplusplus
}
#endif

#endif // GAMEPAD_CONTROLLER_H
```

#### main/gamepad_controller.c
```c
/**
 * @file gamepad_controller.c
 * @brief æ¸¸æˆæ‰‹æŸ„æ§åˆ¶å™¨å®ç°
 */

#include "gamepad_controller.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"

static const char *TAG = "GAMEPAD_CTRL";

// é™æ€å˜é‡
static control_mode_t current_mode = CONTROL_MODE_DISABLED;
static gamepad_state_t current_state = {0};
static SemaphoreHandle_t state_mutex = NULL;

/**
 * @brief æ‰‹æŸ„è¾“å…¥å¤„ç†ä»»åŠ¡
 */
static void gamepad_input_task(void *parameter)
{
    ESP_LOGI(TAG, "Gamepad input task started");
    
    while (1) {
        // TODO: ä»è“ç‰™HIDæ¥æ”¶æ‰‹æŸ„æ•°æ®
        // è¿™é‡Œæš‚æ—¶æ¨¡æ‹Ÿæ•°æ®å¤„ç†
        
        if (xSemaphoreTake(state_mutex, portMAX_DELAY) == pdTRUE) {
            // æ›´æ–°æ‰‹æŸ„çŠ¶æ€
            // current_state.connected = true; // ç¤ºä¾‹
            xSemaphoreGive(state_mutex);
        }
        
        vTaskDelay(pdMS_TO_TICKS(10)); // 100Hz æ›´æ–°é¢‘ç‡
    }
}

/**
 * @brief æ§åˆ¶è¾“å‡ºå¤„ç†ä»»åŠ¡
 */
static void control_output_task(void *parameter)
{
    ESP_LOGI(TAG, "Control output task started");
    
    while (1) {
        gamepad_state_t state;
        if (gamepad_controller_get_state(&state) == ESP_OK && state.connected) {
            
            switch (current_mode) {
                case CONTROL_MODE_CAR:
                    // TODO: å¤„ç†å°è½¦æ§åˆ¶é€»è¾‘
                    break;
                    
                case CONTROL_MODE_PLANE:
                    // TODO: å¤„ç†é£æœºæ§åˆ¶é€»è¾‘
                    break;
                    
                case CONTROL_MODE_DISABLED:
                default:
                    // åœæ­¢æ‰€æœ‰è¾“å‡º
                    break;
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(20)); // 50Hz æ§åˆ¶é¢‘ç‡
    }
}

esp_err_t gamepad_controller_init(void)
{
    ESP_LOGI(TAG, "Initializing gamepad controller...");
    
    // åˆ›å»ºäº’æ–¥é”
    state_mutex = xSemaphoreCreateMutex();
    if (state_mutex == NULL) {
        ESP_LOGE(TAG, "Failed to create state mutex");
        return ESP_ERR_NO_MEM;
    }
    
    // åˆå§‹åŒ–çŠ¶æ€
    memset(&current_state, 0, sizeof(current_state));
    current_mode = CONTROL_MODE_DISABLED;
    
    // åˆ›å»ºä»»åŠ¡
    BaseType_t ret;
    ret = xTaskCreate(gamepad_input_task, "gamepad_input", 4096, NULL, 10, NULL);
    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create gamepad input task");
        return ESP_ERR_NO_MEM;
    }
    
    ret = xTaskCreate(control_output_task, "control_output", 4096, NULL, 9, NULL);
    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create control output task");
        return ESP_ERR_NO_MEM;
    }
    
    ESP_LOGI(TAG, "Gamepad controller initialized successfully");
    return ESP_OK;
}

esp_err_t gamepad_controller_set_mode(control_mode_t mode)
{
    ESP_LOGI(TAG, "Setting control mode to %d", mode);
    current_mode = mode;
    return ESP_OK;
}

esp_err_t gamepad_controller_get_state(gamepad_state_t *state)
{
    if (state == NULL) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (xSemaphoreTake(state_mutex, pdMS_TO_TICKS(10)) == pdTRUE) {
        memcpy(state, &current_state, sizeof(gamepad_state_t));
        xSemaphoreGive(state_mutex);
        return ESP_OK;
    }
    
    return ESP_ERR_TIMEOUT;
}

esp_err_t gamepad_controller_vibrate(uint8_t intensity, uint32_t duration_ms)
{
    ESP_LOGI(TAG, "Vibrating: intensity=%d, duration=%lu ms", intensity, duration_ms);
    // TODO: å®ç°éœ‡åŠ¨åŠŸèƒ½
    return ESP_OK;
}
```

## ğŸ“¦ ç¬¬äºŒæ­¥ï¼šåˆ›å»ºè‡ªå®šä¹‰ç»„ä»¶

### 2.1 è“ç‰™HIDç»„ä»¶ç»“æ„

```bash
components/bluetooth_hid/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ include/
â”‚   â””â”€â”€ bluetooth_hid.h
â””â”€â”€ src/
    â””â”€â”€ bluetooth_hid.c
```

#### components/bluetooth_hid/CMakeLists.txt
```cmake
idf_component_register(
    SRCS "src/bluetooth_hid.c"
    INCLUDE_DIRS "include"
    REQUIRES 
        bt
        esp_bt_bluedroid
        driver
)
```

### 2.2 è®¾å¤‡æ§åˆ¶ç»„ä»¶ç»“æ„

```bash
components/device_control/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ car_control.h
â”‚   â””â”€â”€ plane_control.h
â””â”€â”€ src/
    â”œâ”€â”€ car_control.c
    â””â”€â”€ plane_control.c
```

### 2.3 éœ‡åŠ¨åé¦ˆç»„ä»¶ç»“æ„

```bash
components/vibration/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ include/
â”‚   â””â”€â”€ vibration.h
â””â”€â”€ src/
    â””â”€â”€ vibration.c
```

## ğŸ”§ ç¬¬ä¸‰æ­¥ï¼šé…ç½®ç®¡ç†

### 3.1 åˆ›å»ºé¡¹ç›®é…ç½®æ–‡ä»¶

#### sdkconfig.defaults
```
# è“ç‰™é…ç½®
CONFIG_BT_ENABLED=y
CONFIG_BT_BLUEDROID_ENABLED=y
CONFIG_BT_CLASSIC_ENABLED=y
CONFIG_BT_HID_HOST_ENABLED=y

# æ—¥å¿—çº§åˆ«
CONFIG_LOG_DEFAULT_LEVEL_INFO=y

# FreeRTOSé…ç½®
CONFIG_FREERTOS_HZ=1000

# å†…å­˜ä¼˜åŒ–
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=4
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=8
```

## âœ… éªŒè¯é¡¹ç›®ç»“æ„

å®Œæˆåçš„é¡¹ç›®ç»“æ„åº”è¯¥å¦‚ä¸‹ï¼š

```
ESP32-Gamepad/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ sdkconfig.defaults
â”œâ”€â”€ main/
â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ gamepad_controller.h
â”‚   â””â”€â”€ gamepad_controller.c
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ bluetooth_hid/
â”‚   â”œâ”€â”€ device_control/
â”‚   â”œâ”€â”€ vibration/
â”‚   â””â”€â”€ config/
â””â”€â”€ docs/
    â”œâ”€â”€ 01-å¼€å‘ç¯å¢ƒæ­å»º.md
    â””â”€â”€ 02-é¡¹ç›®åŸºç¡€æ¶æ„æ­å»º.md
```

## ğŸš€ ç¬¬å››æ­¥ï¼šç¼–è¯‘éªŒè¯

### 4.1 åˆå§‹ç¼–è¯‘
```bash
cd /Users/xuqi/Proj/ESP32-Gamepad
idf.py build
```

### 4.2 é¢„æœŸç»“æœ
- ç¼–è¯‘æˆåŠŸï¼Œç”Ÿæˆbuildç›®å½•
- è¾“å‡ºç±»ä¼¼ï¼š`Project build complete. To flash, run: idf.py flash`

---

**ä¸‹ä¸€æ­¥**: [03-è“ç‰™HIDåè®®å®ç°.md](./03-è“ç‰™HIDåè®®å®ç°.md)

*åˆ›å»ºæ—¶é—´ï¼š2025å¹´7æœˆ7æ—¥*
